---
layout: post
title: Detection And Tracking of Moving Objects
visible: 1
---

## Background
We have already solved the SLAM problem to model the static parts of the enviroments, filtering the dynamic parts. We know the localization of the vehicle and a representation of the static map, where we have removed the dynamic objects. The static map is represented with a grid map, where each cell contains the probability that that cell is occupied. 

![alt text](../images/slam/Example_slam_map.png "Example of map from SLAM")

# Overview
In this part we want to find the dynamic parts of the map, and solve the DATMO problem (Detection And Tracking of Moving Objects) for the map generate by the vehicle.

There are methods that solve this problem by separating the detection and tracking parts, and calculate them independently. In this approach, the tracker takes a list of moving objects generated by the detector, using temporal information, and the tracker generates the trajectories. And the, it applies filtering techniques to calculate the dynamics of the objects. But, in this approach, because we have separated the detection, we can obtain wrong results, with either missing detections or false alarms. Here we are solving the detection and tracking simoultaneously with a probabilistic approach using temporal information, which is more robust.

In general, this method could be used without using a model of the detected objects, but with only LIDAR information, it is difficult to find the correct model of the object. So we are going to use some predefined models, in particular, IÂ´m going to focus on detecting only cars, to represent the dynamic objects.

In summary, this method will use the hypothesis of dynamic objects generated in the SLAM method, to create trajectories of dynamic objects that fit the predefined models, and are composed of consistent measurements over time. This is an expensive method, so we are going to solve this using the Markov Chain Monte Carlo (MCMC) algorithm to generate the optimal trajectories of dynamic objects.

## Moving Objects Hypothesis Generation
### Define Dynamic Map

The first step is to create a grid map with information that represents the hypothesis for the dynamic enviroment. We say that they hypothesis, because not every possibility to be a dynamic object in this grid map is going to be part of the set of dynamic objects that we will end up having.

In this grid map, every cell will be a boolean that represent if that cell may be part of a moving object. To calculate this value there are two possible ways:

- If a cell was empty in the previous time step, or we detected a moving object in that cell, and we detect and obstacle in the current timestep, then we say that there may be a moving object in that cell, and we put 1.
- If the cell was empty or unknow in the previous time step, or we detected a moving object in that cell, and we detect and obstacle in the current timestep, then we say that there may be a moving object in that cell, and we put 1.

The difference between the two approaches is that in the first one we are more conservative, but we will miss some moving objects. In the second approach, we will generate some false alarms, but we will detect all moving objects. Imagine an scenario, where there is a moving object in front of us and it is moving forward, relative to our vehicle. Then as it moves, it will always move into unknow territory because the LIDAR can "see" through it. So here, we are going to use the second approach, because it will provide better results, and generate a more robust algorth.

This dynamic map will have the same structure as the static grid map, but we will only consider the information of the local map, and we will not update the global map, as we don't have information about it.

TODO: Add a picture.

### Find the Objects Hypothesis from the dynamic map
The next step is use the grid map representing the possible dynamic enviroment that we have found in the previous step, and use this grid map to calculate the hypothesis of the moving objects. These objects are going to be composed of a list of all the cells, pairs (x, y) that define the cell in the local map, the model that represents the object, the position and orientation, which can be found from the model that we have used to fit the points.

We start first by clustering the points in the grid map. From here on, for each cell in the grid map, we are going to work only with the points that are at the center of the cell, and the distance between two cells, is going to be the euclidean distance between the centers of the points. Also, because we are working with discrete detections, when we are clustering the points, we need to define a maximum distance threshold, where we say that if the distance between two points is less than that threshold, they are connected. We do this because it is not neccesary that two cells in the grid map are going to have LIDAR information.

In order to cluster the points, we are going to use the Disjoint-Set data structure. We are going to start by doing a double for loop, the first one over every point in the grid map, and a second one over all neighbouring points of the first point, that are inside the threshold. Then if both points are detected as dynamic, if they contain a 1 in the dynamic grid map, we can connect them. After this, we have for every point, the root of the connected component that they belong to. So we can create a map from the root id, to a list of points that belong to that connected component. So in this step, the output will be a map that contains lists with all the points of the components that will create the hypothesis of the moving ojects. The key of the map is not really important, and can contain any value, but it is useful to give a number between 1 and N, being N the number of hypothesis.

TODO: Add image of cluster

Now, for each object, we have a list of points, and we want to represent those points as the model of an object. In general we can use a rectangle for the model. We usually only detect objects like cars, bikes, pedestrians, all of which can be represented by a rectangle. We want to find the rectangle of less area that will contain each point (detection) which we have representing the object. We are going to use a two step algorithm, first we need to calculate the regular polygon that fits the list of points, which can be easily calculated with the Convex Hull algorithm. Then we can calculate the rectangle of minimum area that contains that polygon.

TODO: Add convex hull code and rectangle fitting.

Finally, we are going to have a list of objects that contain information of the detections, and the position and orientation of the object that can be calculated from the rectangle after which we have modeled the detected points. These are the representation of the moving objects that we are going to use. Of course, some of these objects won't represent a real object, we can obtain, for example, rectangle of (10m, 1m) dimensions, but we are not going to rejected them here yet.

TODO: Add image of rectangles.

## Generate the trajectories

Now that we have the hypothesis of the moving objects for some time t, in order to generate the trajectories of the moving objects we are going to consider a time window approach, using the information of various consecutive time steps (around 10), and calculate the solution that optimizes a probability distribution $\pi(w)$ (in our case $\pi(w) = P(w|Z)$).

### Neighboring Graph

We have hypothesis of moving objects for different time steps, and are going to create a graph, where the nodes are these objects and the edges will be added between nodes in consecutive time steps when we can reach one from the other realisticly, so for example, we can define a maximum velocity that the car can have, and by knowing the positions and the time difference, calculate if the necessary velocity for reach the other point is less than the maximum velocity that we have defined.

Later, we are going to need to add and remove edges from this graph, so we are going to use an adjacency set to store the edges for the nodes, and make the graph dynamics, we will be able to add/remove any node/edge.

### Markov Chain Monte Carlo Method

We want to solve the problem of maximizing the posterio probability in a discrete and continuous space of high dimension. We are going to use the Markov Chain Monte Carlo Method (MCMC) with jump/diffusion dynamics to sample the solutions. The jump method will help us move to different discrete states, and changing the dimensionality of the solution, and the diffusion will sample the continuous space when generate a new state.

The MCMC algorithm will find the state that maximizes a probability distribution, by sampling new states and calculating the following probability:

$$ A(w_{n-1}, w') = \min{(1, \frac{\pi(w')}{\pi(w'_{n-1}\frac{q(q_{n-1}|w')}{q(w'|w_{n-1})})})} $$

So if we have a previous state $w_{n-1}$, we are going to generate a new state $w'$ from the current state $w_n$ following the proposal distribution $q(w' \|w_{n-1})$, and the new candidate $w'$ is accepted with the probability $ A(w_{n-1}, w')$. Otherwise we stay with $w_{n-1}$.

We have that $\pi(w) = P(w \|Z)$ and $\frac{q(q_{n-1} \|w')}{q(w' \|w_{n-1})}$ expresses the relative difficulty of going from $w'$ to $w_{n-1}$ and vice versa.

The algorithm is:

> for n = 1 to max_iter 
 <br />
> &nbsp;&nbsp;Propose w' according to $q(w' \|w_{n-1})$
<br />
> &nbsp;&nbsp;Sample U from Uniform[0, 1]
<br />
> &nbsp;&nbsp;if U < $A(w, w')$
<br />
> &nbsp;&nbsp;&nbsp;&nbsp;$w_n = w'$
<br />
> &nbsp;&nbsp;&nbsp;&nbsp;if $P(w_n \|Z)$ > $P(w* \|Z)$
<br />
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$w* = w_{n-1}$
<br />
> &nbsp;&nbsp;else
<br />
> &nbsp;&nbsp;&nbsp;&nbsp;$w_n = w_{n-1}$
<br />

### Markov chain dynamics

The Markov chain dynamics consists of methods of sampling the proposal distribution $q(w'|w_{n-1})$. Here we propose some dynamics that advance the concept of jump/diffusion that we talked before.
These dynamics will help us walk through defined space using the probability distribution.

- **Track Extension/Reduction**: We will extend a track by selecting uniformly at random (u.a.r) a node which has an edge to the node at the end of the track, and append it to the track. We can do the same prepending a node at the begining of the track.
The reduction consists of selecting a node of the track, and removing either all nodes in the back or the beginning.
The track we are modifying here is also selected u.a.r out of all possible tracks.

- **Track Birth/Death**: For the birth of a track, we select a node u.a.r. that doesn't belong to any track, and create a new track. After this move we try to extend this track either at the end or at the begining. If we can't extend the track, we reject this move.
The death is simply selecting u.a.r. a track and removing it.

- **Track Split/Merge**: For the split dynamic, we selct a track u.a.r. and divide it in two new tracks by splitting it by some node.
For merging, we selct u.a.r. two tracks, from all the pairs of tracks that can be merged, and create one track by merging the two.

- **Track Switch**: Here, we take two tracks, and two nodes, one in each track. Then we will divide both tracks, and merge the first part of one track, with the last of the other. And the same for the other parts.

- **Track Diffusion**: Here we select one track and one node u.a.r., and update the position and orientation of the object under some random noise.

To calculate the probability to go from one state to the other, we can use the probabilities distributions to calculate the probability. From example, if we have taken a node u.a.r., and we have N nodes, $P(w' \|w_{n-1}) = 1/N$. And we can calculate this probability for all dynamics. Also, because the dynamics are reversible, it is easy to calculate the probability $P(w_{n-1} \|w')$.

### Posterior Probability

We want to find the tracks that maximize the posterior probability, which is the probability to have seen a set of tracks of moving objects w given the LIDAR measruments Z, $P(w \|Z)$.

Using Bayes rules, we can divide this probability in two terms, the prior probability $P(w)$ and the likelyhood probability $P(Z \|w)$, and obtain the following approximation.

$$ P(w|Z) \approx P(w)P(Z|w)$$

#### Prior Probability

The prior probability is the probability of having the set of tracks without taking into account the measurements. We can calculate the prior probability independently for each tracks, and the result will be the product of the probability for each track.

$$P(w) = \prod P(\tau_k)$$

The prior probability can also divided into two terms. One will be the probability of an object, independently of the others, without taking into account the temporal information $P_O(\tau_k)$. And other term to take into account temporal information $P_T(\tau_k)$. But if we only consider these terms, we will be optimizing for shorter tracks, so we need to add another term, to obtain longer tracks $P_L(\tau_k)$.

- $P_L(\tau_k)$: In order to obtain longer tracks, we can use an exponential function over the length. So if we define the length of the track as L, then

$$P_L(\tau_k) \propto exp(-L*\lambda_L)$$

- $P_O(\tau_k)$: The probability of finding the objectsat some position and orientation is used for taking into account certain hypothesis, such as that it is more likely to encounter a car in the street, in the middle of the lane, facing the direction of the street, rather than in the sidewalk. And we could say similar things for pedestrians, bikes, ... In this case, we are going to simplify this, and using a uniform probability, but we could calculate the lanes of the road using cameras, ...

- $P_T(\tau_k)$: This is the probability that takes into account the dynamics of the objects. The approach that we use here, is to use a filter, here the Extended kalman Filter, to calculate the probability of the track. To do this, we can calculate the covariance of the track with EKF, and minimize the covariance.

$$P_T(\tau_k) \propto exp(-cov*\lambda_T)$$

### Likelyhood probability

The likelyhood probability $P(Z \|w)$ is the probability of having an observation Z given the trajectories w, where the observations Z contains both dynamic and static information.

We can divide this probability in four terms, to predict the incompatibilites between the trajectories and the LIDAR measurments. 

- The first term $P_1(Z \|w)$ will minimize the differences between the detections and the object that we have predicted. we expect that all LIDAR beams will hit the vehicle in the visible part. But we can have detections that are outside the model of the object, because by diffusion in the Markov chain dynamics we have updated the position or orientation of the object, and detections inside due to errors or the shape of the object. In this case we are going to calculate the theoretical point were the beams should have hit the vehicle, can calculate the distance from the actual hit point. Then we can minimize this distance by using an exponential function. For one object we have:

$$P_1(Z|w) \propto exp(-\lambda_1*d)$$

- $P_2(Z \| w)$ will be used for the cases were the moving objects have been detected in a position were we detected previously a static object. So we can count the number measurements that have this condition, $c_2$. And the probability will be:

$$P_2(Z|w) \propto exp(-\lambda_2*c_2)$$

- $P_3(Z \|w)$ uses the number of measurements, whose beam trasverses an static object, $c_3$:

$$P_3(Z|w) \propto exp(-\lambda_3*c_3)$$

- $P_4(Z \|w)$ is similar to the previous probability but considering dynamic objects, $c_4$:

$$P_4(Z|w) \propto exp(-\lambda_4*c_4)$$